# Создание распределенной системы с помощью RMI

В примере выполняются четыре основных действия:

* определение удаленного интерфейса с объявлениями методов, которые клиент может вызвать у удаленного объекта;
* определение реализации удаленного объекта для удаленного интерфейса;
* определение клиентского приложения, которое использует удаленную ссылку, чтобы взаимодействовать с реализацией интерфейса;
* компиляция и выполнение удаленного объекта и клиента.

Создадим систему, функционально состоящую из двух компонентов - сервера (процессингового центра) и клиента (касса). Будем предполагать, что сервер в системе один (именно он обладает всей информацией о зарегистрированных картах и их балансах), а касс много и на них проходят операции регистрации новых карт, а также операции изменения баланса карт (соответственно - оплаты и занесения наличных).

На данном этапе мы никак не будем учитывать то, что связь между нашими объектами неустойчивая, - более того, мы будем считать ее устойчивой. Кроме того, в целях сокращения размеров примеров не будут рассматриваться вопросы долговременного хранения обрабатываемой информации - при перезапуске наша система будет "забывать" все занесенные в нее карты и их балансы.

**Определение удаленного интерфейса**

При проектировании сервера нам необходимо определить выполняемые им функции и, соответственно, методы, которые будет вызывать клиент. Поскольку операциями нашей системы являются регистрация новой карты, занесение денег на карту, оплата картой покупки и просмотр баланса карты, будем считать, что наш сервер будет обладать четырьмя перечисленными методами - именно их клиент (касса) и будет вызывать. Поскольку единственным, что отличает одну карту от другой, является ее номер (код) - он и будет служить идентификатором, карты и поэтому будет присутствовать во всех методах сервера в качестве параметра. Поскольку этот код, вообще говоря, алфавитно-цифровой, будем использовать тип данных String для его хранения.

Удаленные методы, посредством которых клиент взаимодействует с удаленным объектом, используя RMI, должны быть определены в удаленном интерфейсе. Соответственно, первый этап при создании распределенного приложения с помощью RMI состоит в определении удаленного интерфейса, который описывает эти удаленные методы. Чтобы создать удаленный интерфейс, необходимо определить интерфейс, который будет расширять интерфейс java.rmi.Remote.Интерфейс Remote представляет собой тегирующий интерфейс - он не объявляет каких-либо методов, поэтому не обременен реализацией класса. Распределенное RMI -приложение должно экспортировать объект класса, который реализует интерфейс Remote,чтобы сделать этот удаленный объект доступным для приема удаленных вызовов метода из любой виртуальной машины Java, которая имеет соединение с компьютером, где выполняется удаленный объект.

Интерфейс BillingService (пример 1), который расширяет интерфейс Remote (строка 9), представляет собой интерфейс для нашего удаленного объекта (сервера). В строках 10-17 объявляются методы для работы с пластиковыми картами. Удаленный объект должен реализовать все объявленные в удаленном интерфейсе методы.

```
1  // BillingService.java
2  // Интерфейс BillingService объявляет методы для работы
3  // с пластиковыми картами
4  package com.asw.rmi.ex1;
5
6  // Набор базовых пакетов Java
7  import java.rmi.*;
8
9  public interface BillingService extends Remote {
10  // определение новой карты
11  public void addNewCard(String personName, String card) throws RemoteException;
12  // добавить денежные средства на карту
13  public void addMoney(String card, double money) throws RemoteException;
14  // снять денежные средства с карты
15  public void subMoney(String card, double money) throws RemoteException;
16  // получение баланса карты
17  public double getCardBalance(String card) throws RemoteException;
18  }
```

Листинг 1. Интерфейс BillingService

Когда узлы взаимодействуют между собой по сети, есть вероятность возникновения проблем при таких взаимодействиях. Например, компьютер сервера может выйти из строя или может отказать какой-либо сетевой ресурс. Поэтому для контроля подобных проблем взаимодействия в сети каждый метод в интерфейсе Remote должен содержать throws для указания, что метод может возбуждать контролируемые исключения RemoteException.

RMI использует механизм сериализации по умолчанию Java для передачи параметров методу и возврата значений через сеть. В связи с этим все параметры метода и возвращаемые значения должны иметь описатель Serializable или один из примитивных типов.

**Реализация удаленного интерфейса**

Следующим этапом является определение реализации удаленного объекта. В нашем случае класс реализации удаленного объекта имеет то же имя, что и удаленный интерфейс, но заканчивается на Impl.

Класс UnicastRemoteObject (пакет java.rmi.server ) представляет базовые функциональные возможности, которые необходимы удаленным объектам для обслуживания удаленных запросов.

Конструкторы и методы класса UnicastRemoteObject возбуждают контролируемое исключение RemoteException,поэтому подклассы класса UnicastRemoteObject должны определять конструкторы, которые также возбуждают исключение RemoteException.

Конструктор класса UnicastRemoteObject экспортирует объект, чтобы сделать его доступным для приема удаленных вызовов. Экспорт объекта дает возможность удаленному объекту ожидать соединений с клиентами на анонимном порте (т.е. порте, выбираемом компьютером, на котором выполняется удаленный объект). Это дает возможность объекту осуществлять однонаправленное взаимодействие (взаимодействие "точка-точка" между двумя объектами посредством вызовов методов) с использованием стандартных соединений через сокеты. Классам удаленных объектов не нужно расширять этот класс, если эти классы применяют статический метод exportObject класса UnicastRemoteObject для экспорта удаленных объектов. Предполагается, что клиенты RMI должны осуществлять соединение на порте 1099 при попытке найти удаленный объект в реестре RMI. Перегруженный конструктор для класса UnicastRemoteObject дает возможность задавать дополнительную информацию, такую как номер порта для экспорта удаленного объекта. Для этого необходимо определить URL, который клиент может использовать для получения удаленной ссылки на объект. Эта ссылка применяется для вызова методов удаленного объекта. URL обычно имеет форму

```
rmi://хост:порт/ИмяУдаленногоОбъекта,
```

где _хост_ представляет собой имя компьютера, который выполняет сервер реестра ( rmiregistry ) для удаленных объектов (он также является компьютером, на котором выполняется удаленный объект), порт представляет собой номер порта, на котором выполняется сервер реестра на хост-компьютере, а _ИмяУдаленногоОбъекта_ - имя, которое клиент будет предоставлять при попытках обнаружить удаленный объект в реестре. Утилита rmi-registry обслуживает реестр удаленных объектов и является составной частью J2SE. Номер порта реестра RMI по умолчанию - 1099.

Для связывания удаленного объекта с реестром используются методы bind или rebind.Метод rebind гарантирует, что если объект уже был зарегистрирован под заданным именем, новый удаленный объект заменит ранее зарегистрированный объект. Это может быть важно, если регистрируется новая версия существующего удаленного объекта.

Класс BillingServiceImpl (пример 2) представляет собой удаленный объект, который реализует удаленный интерфейс BillingService.Клиент взаимодействует с объектом класса BillingServiceImpl,вызывая методы addNewCard, addMoney, subMoney, getCardBalance интерфейса BillingService для обработки информации по пластиковым картам. Класс BillingServiceImpl хранит сведения о картах в хэш-таблице (Hashtable),содержащей баланс пластиковой карты с именем посетителя (personName) и номером пластиковой карты ( card ), где номер карты является ключом таблицы.

```
1  // BillingServicelmpl.java
2  // BillingServiceImpl реализует удаленный интерфейс BillingService
  для
3  // предоставления удаленного объекта BillingService
4  package com.asw.rmi.ex1;
5
6  // Набор базовых пакетов Java
7  import java.rmi.*;
8  import java.util.*;
9  import java.rmi.server.*; 
10
11  public class BillingServiceImpl extends UnicastRemoteObject
12  implements BillingService {
13
14  private   Hashtable hash;   // хэш-таблица для хранения карт
15  // инициализация сервера
16  public BillingServiceImpl() throws RemoteException{
17  super();
18  hash = new Hashtable();
19  }
20
21  // реализация метода addNewCard интерфейса BillingService
22  public void addNewCard(String personName, String card)
23  throws RemoteException {
24
25  hash.put(card, new Double(0.0));
26  }
27
28  // реализация метода addMoney интерфейса BillingService
29  public void addMoney(String card, double money) throws RemoteException {
30  Double d = (Double)hash.get(card);
31
32  if (d!=null) hash.put(card,new Double(d.doubleValue()+money));
33  else throw new NotExistsCardOperation();
34  }
35
36  // реализация метода subMoney интерфейса BillingService
37  public void subMoney(String card, double money) throws RemoteException {
38  Double d = (Double)hash.get(card);
39
40  if (d!=null) hash.put(card,new Double(d.doubleValue()-money));
41  else throw new NotExistsCardOperation();
42  }
43
44  // реализация метода getCardBalance интерфейса BillingService
45  public double getCardBalance(String card) throws RemoteException {
46  Double d = (Double)hash.get(card);
47  if (d!=null) return d.doubleValue();
48  else throw new NotExistsCardOperation();
49  };
50
51  // запуск удаленного объекта BillingService
52  public static void main (String[] args) throws Exception {
53  System.out.println("Initializing BillingService...");
54
55  // создание удаленного объекта
56  BillingService service = new BillingServiceImpl();
57
58  //задание имени удаленного объекта
59  String serviceName = "rmi://localhost/BillingService";
60  // регистрация удаленного объекта BillingService в реестре rmiregistry
61  Naming.rebind(serviceName, service);
62  }
63
64  }
```

Листинг 2. Класс BillingServiceImpl реализует удаленный интерфейс BillingService

Класс BillingServiceImpl реализует методы addNewCard (строки 22-26), addMoney (строки 29-34), subMoney (строки 37-42), getCardBalance (строки 45-49) интерфейса BillingService,чтобы отвечать на удаленные запросы.

Метод main (строки 52-62) создает удаленный объект BillingServiceImpl.Когда конструктор выполняется, он экспортирует удаленный объект, чтобы прослушивать удаленные запросы. В строке 59 определяется URL, который клиент может применить для получения удаленной ссылки на объект для вызова методов удаленного объекта.

В этой программе URL удаленного объекта имеет вид [rmi://localhost/BillingService](rmi://localhost/BillingService). Из этого следует, что реестр RMI выполняется на машине _localhost_ (т.е. на локальном компьютере), а для обнаружения клиентом сервиса нужно использовать имя _BillingService_.Имя _localhost_ является синонимом IP -адреса 127.0.0.1 ( loopback ).

В строке 61 вызывается статический метод rebind класса Naming (пакет java.rmi) для связывания удаленного объекта service класса BillingServiceImpl в реестре RMI с URL [rmi://localhost/BillingService](rmi://localhost/BillingService).

Класс NotExistsCardOperation (пример 3) расширяет класс RemoteException.

```
1  // NotExistsCardOperation.java
2  package com.asw.rmi.ex1;
3
4  // Набор базовых пакетов Java
5  import java.rmi.RemoteException;
6
7  public class NotExistsCardOperation extends RemoteException {
8
9  }
```

Листинг 3. Класс NotExistsCardOperation реализует обработку исключений

Далее мы определяем клиентское приложение, которое будет обрабатывать запросы к пластиковым картам и пересылать их серверу. Для работы клиентского приложения необходимо знать URL вызываемого им удаленного объекта. Статический метод lookup класса Naming применяется для получения объектной ссылки на удаленный объект с заданным URL. Метод lookup осуществляет соединение с реестром RMI и возвращает удаленную ссылку на удаленный объект. Клиент может использовать эту удаленную ссылку, если она обращается к локальному объекту, выполняющемуся на той же виртуальной машине. Эта удаленная ссылка обращается к _объекту-заглушке_ на клиенте. Заглушки дают возможность клиентам вызывать методы удаленного объекта. Объекты-заглушки принимают удаленные вызовы метода и передают эти вызовы RMI, который выполняет сетевые соединения, позволяющие клиентам взаимодействовать с удаленным объектом. Уровень RMI отвечает за сетевые соединения с удаленными объектами, поэтому обращения к удаленным объектам являются прозрачными для пользователя. RMI обслуживает соединение с удаленным объектом, передачу параметров и возврат значений.

<figure><img src="../../.gitbook/assets/05_01.png" alt="" width="442"><figcaption><p>Рис. 1. Архитектура RMI</p></figcaption></figure>

Класс BillingClient (пример 4) является клиентским приложением, которое вызывает удаленные методы addNewCard, addMoney и getCardBa-lance интерфейса BillingService для работы с пластиковыми картами посетителей через RMI. В нашем примере мы не реализуем реальную работу касс столовых с пластиковыми картами. Для иллюстрации определения и работы клиентского приложения нам достаточно произвести несколько операций с несколькими картами, используя удаленные методы удаленного объекта. В данном случае клиент в цикле заносит денежные средства на три пластиковые карты и в конце печатает результирующий баланс по этим пластиковым картам. При первом проходе цикла в случае отсутствия карт с заданными номерами клиент их создает.

```
1  // BillingClient.java
2  // BillingClient использует удаленный объект BillingService для
3  // работы с информацией на пластиковых картах
4  package com.asw.rmi.ex1;
5
6  // Набор базовых пакетов Java
7  import java.rmi.*;
8
9  public class BillingClient {
10  // выполнение BillingClient
11  public static void main(String[] args) throws Exception]
12  // создание строки, содержащей URL удаленного объекта
13  String objectName = "rmi://"+args[0]+"/BillingService";
14  System.out.println("Starting...\n");
15  // соединение с реестром RMI и получение удаленной ссылки
16  // на удаленный объект
17  BillingService bs = (BillingService)Naming.lookup(objectName);
18  System.out.println("done");
19
20  // начисление денежных средств на пластиковые карты
21  for (int i = 0; i < 10000;  i++) {
22  try {
23  bs.addMoney("1", 1);
24  } catch (RemoteException   e) {
25  bs.addNewCard("Piter", "1");
26  } 
27
28  try {
29  bs.addMoney("2", 1);
30  } catch (RemoteException   e) {
31  bs.addNewCard("Stefan", "2");
32  } 
33
34  try {
35  bs.addMoney("3", 1);
36  } catch (RemoteException   e) {
37  bs.addNewCard("Nataly", "3");
38  }
39  }
40  // печать текущего баланса обработанных карт
41  System.out.println("1:"+bs.getCardBalance("1"));
42  System.out.println("2:"+bs.getCardBalance("2"));
43  System.out.println("3:"+bs.getCardBalance("3"));
44  }
45  }
```

Листинг 4. Клиентское приложение BillingClient для удаленного объекта BillingService

Метод main (строки 11-44) принимает в качестве параметра имя компьютера, на котором выполняется удаленный объект BillingService.В строке 13 создается строка objectName,которая содержит URL для нашего удаленного объекта. В строке 17 вызывается метод lookup класса Naming для получения удаленной ссылки на удаленный объект BillingService с заданным URL. В строках 21-38 производится добавление денежных средств на карты, а в строках 41-43 - печать текущего баланса этих карт.

**Компиляция и выполнение сервера и клиента**

Подготовив отдельные фрагменты, мы можем сформировать и выполнить наше распределенное приложение, но для этого потребуется несколько действий. Для начала необходимо компилировать исходные классы. Далее, нужно компилировать класс удаленного объекта ( ...Impl ), используя компилятор rmic (утилита J2SE ) для формирования класса-заглушки (о котором говорилось в предыдущем разделе). Этот класс должен быть доступен для клиента (либо локально, либо путем загрузки по сети), чтобы дать возможность устанавливать удаленное соединение с серверным объектом. В зависимости от параметров командной строки, передаваемых rmic,может быть сгенерировано несколько файлов. В Java 1.1 rmic формирует два класса - класс-заглушку и класс-каркас ( skeleton ). В Java 2 класс-каркас больше не требуется. Параметр командной строки -v1.2 указывает, что rmic следует создать только класс-заглушку.

Для нашего примера командная строка для компиляции класса удаленного объекта будет выглядеть следующим образом:

```
rmic -v1.2 com.asw.rmi.ex1.BillingServiceImpl
```

которая сгенерирует файл BillingServiceImpl\_Stub.class.

Следующий этап - запуск реестра RMI, который зарегистрирует удаленный объект. Командная строка

```
rmiregistry
```

запускает реестр RMI на локальной машине. В окне командной строки в ответ на эту команду никакого текста отображаться не будет. Типичная ошибка заключается в том, что если не запустить реестр RMI прежде чем попытаться привязать удаленный объект к реестру, будет сгенерировано исключение java.rmi.ConnectException,которое указывает, что программа не может соединиться с реестром.

Чтобы удаленный объект мог принимать удаленные вызовы методов, необходимо связать объект с именем в реестре RMI. Для этого нужно запустить серверное приложение из командной строки. В нашем случае командная строка выглядит так:

```
java com.asw.rmi.ex1.BillingServiceImpl
```

В результате отображается сообщение об инициализации BillingService.

Теперь клиентское приложение может соединиться с удаленным объектом, выполняющимся на локальной машине localhost. Команда

```
java com.asw.rmi.ex1.BillingClient
```

соединит BillingClient с объектом BillingServiceImpl.

Если серверное приложение выполняется не на клиенте, можно указать IP -адрес или доменное имя компьютера-сервера в качестве параметра командной строки при выполнении клиента. Например, чтобы осуществить доступ к компьютеру с IP -адресом 192.168.1.1, введем команду

```
java com.asw.rmi.ex1.BillingClient 192.168.1.1
```

Несколько слов о синхронизации

Теперь, после того как нами реализовано первое приложение с использованием RMI, настало время немного поговорить об одной из особенностей, связанной с применением этой технологии.

Дело в том, что при вызове клиентом метода удаленного объекта исполняющей частью системы на стороне сервера формируется (или выбирается из числа уже созданных) поток, в котором и происходит вызов. Таким образом, становится возможным одновременное выполнение методов сервера несколькими клиентами.

Непонимание этого факта может привести к ошибкам при программировании серверных объектов, которые затем будет очень сложно локализовать и устранить. Для иллюстрации рассмотрим один из возможных сценариев выполнения нашего приложения, в случае если два клиента одновременно вызывают метод addMoney для одной и той же карты (на приведенной схеме (таблица 1) события разворачиваются во времени - время течет сверху вниз):

Таблица 1. Схема выполнения метода addMoney двумя потоками

|    |                                                               |                                                                |
| -- | ------------------------------------------------------------- | -------------------------------------------------------------- |
| t  | Клиент 1                                                      | Клиент 2                                                       |
| t1 | Вызов метода сервера addMoney с номером карты 1 и суммой 10   | Вызов метода сервера addMoney с номером карты 1 и суммой 12    |
| t2 | Double d = (Double)hash.get(card);                            | Double d = (Double)hash.get(card);                             |
| t3 | if (d!=null) hash.put(card,new Double(d.doubleValue()+money)) |                                                                |
| t4 |                                                               | if (d!=null) hash.put(card,new Double(d.doubleValue()+money)); |
| t5 |                                                               |                                                                |

Итак, в момент t1 оба клиента вызывают метод addMoney для карты с номером 1 и с разными суммами начисления (мы предполагаем, что карта с таким номером существует). Далее по каким-то причинам выполнение потоков, в которых происходит работа методов addMoney для первого и второго клиентов, происходит с разными скоростями. В момент времени t2 первый клиент получает из хэша значение баланса карты - второй делает то же самое. В момент времени t3 первый клиент изменяет значение баланса, прибавляя к нему свое начисление, и возвращает баланс в хэш. Ту же самую операцию, но только в момент времени t4 - позднее, чем первый - делает второй клиент. В результате приведенного сценария в хэше окажется значение баланса, измененное вторым клиентов, а изменения, которые сделал первый клиент, просто потеряются - т.е. созданное нами приложение отработает неправильно.

Эффект, в результате которого результат работы приложения зависит от скорости выполнения потоков (фактически - от последовательности действий), в литературе получил название "гонка потоков". Об этой и других проблемах, связанных с разработкой "параллельных" приложений, речь пойдет ниже, в соответствующем разделе. Пока же, для того чтобы обеспечить работоспособность нашего приложения, попробуем добавить ключевое слово synchronized в описание метода addMoney,получив следующее объявление (пример 5).

```
public synchronized void addMoney(String card, double money) throws RemoteException {
  
  Double d = (Double)hash.get(card);
  
  if (d!=null) hash.put(card,new Double(d.doubleValue()+money));
  else throw new NotExistsCardOperation();
}
```

Листинг 5.

Таким образом, будет гарантировано то, что в указанный метод одномоментно сможет войти только один поток - приведенный сценарий станет невозможным1.

Может показаться, что, введя синхронизацию на уровне методов, мы решили проблему, однако это не так. Чтобы убедиться в этом, достаточно рассмотреть одновременное выполнение двух разных методов - addMoney и subMoney - с теми же самыми предположениями о скоростях выполнения. Несложно догадаться, что в приведенном примере блокировка должна выполняться не на уровне методов, а на уровне ресурсов - в нашем случае хэш-таблицы. Для окончательного устранения нежелательного эффекта код всех методов изменения баланса должен быть переписан как-нибудь так2 (пример 6).

```
public void addMoney(String card, double money) throws RemoteException{
    synchronized (hash) {
      Double d = (Double) hash.get(card);

      if (d != null)
        hash.put(card, new Double(d.doubleValue() + money));
      else throw new NotExistsCardOperation();
    }
  }
```

Листинг 6.

